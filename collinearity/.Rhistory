ct     <- 0.5
cmat.t <- matrix(c(1,ct,ct,1), 2)
mt     <- c(a=110, b=105)
ts.t   <- mvrnorm(n, mu=mt, Sigma=cmat.t, empirical=T)
cor(ts.t)
colMeans(ts.t)
cr     <- 0.2
cmat.r <- matrix(c(1,cr,cr,1), 2)
mt     <- c(a=100, 100)
ts.mat <- mvrnorm(n, mu=mt, Sigma=cmat.r, empirical=T)
cor(ts.r)
colMeans(ts.r)
ts.r   <- mvrnorm(n, mu=mt, Sigma=cmat.r, empirical=T)
cor(ts.r)
colMeans(ts.r)
mt     <- c(a=100, b=100)
ts.r   <- mvrnorm(n, mu=mt, Sigma=cmat.r, empirical=T)
cor(ts.r)
colMeans(ts.r)
ts     <- rbind(ts.r, ts.r)
rep(c(1,0), each=n)
df     <- cbind(task=rep(c(1,0), each=n), ts)
head(df)
lm(b ~ a)
lm(b ~ a, data=df)
df     <- as.data.frame(cbind(task=rep(c(1,0), each=n), ts))
lm(b ~ a, data=df)
cor(ts)
ts     <- rbind(ts.t, ts.r)
df     <- as.data.frame(cbind(task=rep(c(1,0), each=n), ts))
lm(b ~ a, data=df)
cor(ts)
lm(b ~ task + a, data=df)
lm(b ~ task + a + task*a, data=df)
lm(b ~ a, data=as.data.frame(ts.t))
lm(b ~ a, data=as.data.frame(ts.r))
lm(b ~ task + a + task*a, data=df)
lm(b ~ task + a, data=df)
?persp
library(MASS)
require(grDevices)
x <- seq(-10, 10, length= 30)
y <- x
f <- function(x, y) { r <- sqrt(x^2+y^2); 10 * sin(r)/r }
z <- outer(x, y, f)
z[is.na(z)] <- 1
op <- par(bg = "white")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
ltheta = 120, shade = 0.75, ticktype = "detailed",
xlab = "X", ylab = "Y", zlab = "Sinc( r )"
) -> res
round(res, 3)
xE <- c(-10,10); xy <- expand.grid(xE, xE)
trans3d(xy[,1], xy[,2], 6, pmat = res)
xy[,1]
xy[,2]
trans3d(x, y = 10, z = 6 + sin(x), pmat = res)
x
xE <- c(-10,10); xy <- expand.grid(xE, xE)
points(trans3d(xy[,1], xy[,2], 6, pmat = res), col = 2, pch = 16)
lines (trans3d(x, y = 10, z = 6 + sin(x), pmat = res), col = 3)
library(lattice)
?wireframe
## volcano  ## 87 x 61 matrix
wireframe(volcano, shade = TRUE,
aspect = c(61/87, 0.4),
light.source = c(10,0,10))
g <- expand.grid(x = 1:10, y = 5:15, gr = 1:2)
g$z <- log((g$x^g$gr + g$y^2) * g$gr)
wireframe(z ~ x * y, data = g, groups = gr,
scales = list(arrows = FALSE),
drape = TRUE, colorkey = TRUE,
screen = list(z = 30, x = -60))
dim(volcano)
volcano[1:4,1:5]
cloud(Sepal.Length ~ Petal.Length * Petal.Width | Species, data = iris,
screen = list(x = -90, y = 70), distance = .4, zoom = .6)
par.set <-
list(axis.line = list(col = "transparent"),
clip = list(panel = "off"))
print(cloud(Sepal.Length ~ Petal.Length * Petal.Width,
data = iris, cex = .8,
groups = Species,
main = "Stereo",
screen = list(z = 20, x = -70, y = 3),
par.settings = par.set,
scales = list(col = "black")),
split = c(1,1,2,1), more = TRUE)
?surface3d
library(rgl)
install.packages("rgl")
library(rgl)
?persp3d
x <- seq(-10, 10, length= 30)
y <- x
f <- function(x,y) { r <- sqrt(x^2+y^2); 10 * sin(r)/r }
z <- outer(x, y, f)
z[is.na(z)] <- 1
open3d()
bg3d("white")
material3d(col="black")
persp3d(x, y, z, aspect=c(1, 1, 0.5), col = "lightblue",
xlab = "X", ylab = "Y", zlab = "Sinc( r )")
xE <- c(-10,10); xy <- expand.grid(xE, xE)
points3d(xy[,1], xy[,2], 6, col = "red")
lines3d(x, y=10, z= 6 + sin(x), col = "green")
?surface3d
data(volcano)
z <- 2 * volcano        # Exaggerate the relief
x <- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y <- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
zlim <- range(y)
zlen <- zlim[2] - zlim[1] + 1
colorlut <- terrain.colors(zlen) # height color lookup table
col <- colorlut[ z-zlim[1]+1 ] # assign colors to heights for each point
open3d()
surface3d(x, y, z, color=col, back="lines")
library(tripack)
install.packages("tripack")
library(tripack)
?tri.plot
?plot.tri
# random points
plot(tri.mesh(rpois(100,lambda=20),rpois(100,lambda=20),duplicate="remove"))
data(quakes)
quakes.part<-quakes[(quakes[,1]<=-10.78 & quakes[,1]>=-19.4 &
quakes[,2]<=182.29 & quakes[,2]>=165.77),]
quakes.tri<-tri.mesh(quakes.part$lon, quakes.part$lat, duplicate="remove")
plot(quakes.tri)
?trans3d
?persp
sample(seq(0, 1, length=5))
crds <- cbind(x=sample(seq(0, 1, length=5)), x=sample(seq(0, 1, length=5)))
crds
crds <- cbind(x=sample(seq(-0.8, 0.8, length=5)), x=sample(seq(-0.8, 0.8, length=5)))
crds
crds <- cbind(x=sample(seq(-0.8, 0.8, length=6)), x=sample(seq(-0.8, 0.8, length=6)))
crds
plot(crds)
plot(crds, type=2)
plot(crds)
abline(x=0)
?abline
plot(crds); abline(h=0); abline(v=0)
plot(crds); abline(h=0, type=3); abline(v=0)
plot(crds); abline(h=0, lty=3); abline(v=0)
plot(crds); abline(h=0, lty=3); abline(v=0, lty=3)
plot(crds, bty='n'); abline(h=0, lty=3); abline(v=0, lty=3)
plot(crds); abline(h=0, lty=3); abline(v=0, lty=3)
plot(crds, xlim=c(-1,1), ylim=c(-1,1)); abline(h=0, lty=3); abline(v=0, lty=3)
points(c(0,0), lwd=2)
points(0, 0, lwd=2)
points(0, 0, lwd=4)
mat1 <- as.matrix(dist(crds))
mean(mat1[lower.tri(mat1)])
vec2 <- sqrt(rowSums(crds^2))
mean(vec2)
#' This calculates the collinearity between the different QC measures
#'
#' We first load the abide and corr dataset
#' then we compute the correlation between the measures within each site
#' we average across sites after doing an r->t->z (this is the difference with the other script)
#' and finally we plot that difference
#'
#+ setup
library(corrplot)
library(RColorBrewer)
library(plyr)
library(fdrtool)
#' # ABIDE
#'
#' ## Setup
#+ abide-setup
# Read
qc_anat <- read.csv("../data/abide_anat.csv", row.names=1)
qc_func <- read.csv("../data/abide_func.csv", row.names=1)
# Fetch relevant columns
anat_cols <- grep("^anat_", names(qc_anat))
func_cols <- grep("^func_", names(qc_func))
# Rename relevant columns for ease
names(qc_anat) <- sub("anat_", "", names(qc_anat))
names(qc_func) <- sub("func_", "", names(qc_func))
#' ## Correlate
#+ abide-correlate
# Anatomical
all_zmats <- daply(qc_anat, .(site), function(x) {
cmat <- cor(x[,anat_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_anat, .(site), nrow)
mean_df <- mean(sqrt(ns-3))
abide_anat <- apply(all_zmats, c(2,3), function(x) tanh(mean(x)/mean_df))
abide_anat_p <- pcor0(abs(abide_anat), mean(ns), lower.tail=F)
# Functional
all_zmats <- daply(qc_func, .(site), function(x) {
cmat <- cor(x[,func_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_func, .(site), nrow)
mean_df <- mean(sqrt(ns-3))
abide_func <- apply(all_zmats, c(2,3), function(x) tanh(mean(x)/mean_df))
abide_func_p <- pcor0(abs(abide_func), mean(ns), lower.tail=F)
# in case you want the original way
abide_anat_orig <- cor(qc_anat[,anat_cols], use="pairwise.complete.obs")
abide_func_orig <- cor(qc_func[,func_cols], use="pairwise.complete.obs")
#' # CoRR
#'
#' ## Setup
#+ corr-setup
# Read
qc_anat <- read.csv("../data/corr_anat.csv", row.names=1)
qc_func <- read.csv("../data/corr_func.csv", row.names=1)
# Fetch relevant columns
anat_cols <- grep("^anat_", names(qc_anat))
func_cols <- grep("^func_", names(qc_func))
# Rename relevant columns for ease
names(qc_anat) <- sub("anat_", "", names(qc_anat))
names(qc_func) <- sub("func_", "", names(qc_func))
# Only include session 1 and scan 1
qc_anat <- subset(qc_anat, session == 1)
qc_func <- subset(qc_func, session == 1 & scan == 1)
# Fix these weird labels
to_num <- function(x) as.numeric(as.character(x))
qc_anat[,anat_cols] <- apply(qc_anat[,anat_cols], 2, to_num)
qc_func[,func_cols] <- apply(qc_func[,func_cols], 2, to_num)
# Update site labels
qc_anat$site <- factor(qc_anat$site)
qc_func$site <- factor(qc_func$site)
#' ## Correlate
#+ corr-correlate
# anatomical
all_zmats <- daply(qc_anat, .(site), function(x) {
cmat <- cor(x[,anat_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_anat, .(site), nrow)
inds <- ns>10
mean_df <- mean(sqrt(ns[inds]-3))
corr_anat <- apply(all_zmats[inds,,], c(2,3), function(x) tanh(mean(x)/mean_df))
corr_anat_p <- pcor0(abs(corr_anat), mean(ns), lower.tail=F)
# functional
all_zmats <- daply(qc_func, .(site), function(x) {
cmat <- cor(x[,func_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_func, .(site), nrow)
inds <- ns>10
mean_df <- mean(sqrt(ns[inds]-3))
corr_func <- apply(all_zmats[inds,,], c(2,3), function(x) tanh(mean(x)/mean_df))
corr_func_p <- pcor0(abs(corr_func), mean(ns), lower.tail=F)
# old way
corr_anat_orig <- cor(qc_anat[,anat_cols], use="pairwise.complete.obs")
corr_func_orig <- cor(qc_func[,func_cols], use="pairwise.complete.obs")
#' # Visualize
#'
#' We look at the abide and corr results together.
#'
#' ## Fixes
#' Since CoRR is missing outliers, we remove that from the abide results
#+ viz-fix-rmcol
rmcol <- which(colnames(abide_func) == "outlier")
abide_func <- abide_func[-rmcol,-rmcol]
abide_func_p <- abide_func_p[-rmcol,-rmcol]
#' We also want to ensure the column names are in the same order.
#' The anatomical is actually fine so only do func cols.
#' We match in reference to the abide functional colnames
#+ viz-fix-ordercol
# anat
all(colnames(abide_anat) == colnames(corr_anat))
# func
ref <- colnames(abide_func)
trg <- colnames(corr_func)
inds <- sapply(ref, function(x) which(trg == x))
corr_func0 <- corr_func # just in case
corr_func <- corr_func0[inds,inds]
#' Now we can combine the two together for one big happy family
#'+ viz-fix-combine
# anat
anat <- abide_anat
anat[upper.tri(anat)] <- corr_anat[upper.tri(anat)]
anat_p <- abide_anat_p
anat_p[upper.tri(anat_p)] <- corr_anat_p[upper.tri(anat_p)]
# func (remove the num_fd column since redundant)
func <- abide_func
func[upper.tri(func)] <- corr_func[upper.tri(func)]
rmind <- which(colnames(func) == "num_fd")
func <- func[-rmind,-rmind]
func_p <- abide_func_p
func_p[upper.tri(func_p)] <- corr_func_p[upper.tri(func_p)]
rmind <- which(colnames(func_p) == "num_fd")
func_p <- func_p[-rmind,-rmind]
setwd("~/Dropbox/Research/cmi/qap_poster/collinearity")
#' This calculates the collinearity between the different QC measures
#'
#' We first load the abide and corr dataset
#' then we compute the correlation between the measures within each site
#' we average across sites after doing an r->t->z (this is the difference with the other script)
#' and finally we plot that difference
#'
#+ setup
library(corrplot)
library(RColorBrewer)
library(plyr)
library(fdrtool)
#' # ABIDE
#'
#' ## Setup
#+ abide-setup
# Read
qc_anat <- read.csv("../data/abide_anat.csv", row.names=1)
qc_func <- read.csv("../data/abide_func.csv", row.names=1)
# Fetch relevant columns
anat_cols <- grep("^anat_", names(qc_anat))
func_cols <- grep("^func_", names(qc_func))
# Rename relevant columns for ease
names(qc_anat) <- sub("anat_", "", names(qc_anat))
names(qc_func) <- sub("func_", "", names(qc_func))
#' ## Correlate
#+ abide-correlate
# Anatomical
all_zmats <- daply(qc_anat, .(site), function(x) {
cmat <- cor(x[,anat_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_anat, .(site), nrow)
mean_df <- mean(sqrt(ns-3))
abide_anat <- apply(all_zmats, c(2,3), function(x) tanh(mean(x)/mean_df))
abide_anat_p <- pcor0(abs(abide_anat), mean(ns), lower.tail=F)
# Functional
all_zmats <- daply(qc_func, .(site), function(x) {
cmat <- cor(x[,func_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_func, .(site), nrow)
mean_df <- mean(sqrt(ns-3))
abide_func <- apply(all_zmats, c(2,3), function(x) tanh(mean(x)/mean_df))
abide_func_p <- pcor0(abs(abide_func), mean(ns), lower.tail=F)
# in case you want the original way
abide_anat_orig <- cor(qc_anat[,anat_cols], use="pairwise.complete.obs")
abide_func_orig <- cor(qc_func[,func_cols], use="pairwise.complete.obs")
#' # CoRR
#'
#' ## Setup
#+ corr-setup
# Read
qc_anat <- read.csv("../data/corr_anat.csv", row.names=1)
qc_func <- read.csv("../data/corr_func.csv", row.names=1)
# Fetch relevant columns
anat_cols <- grep("^anat_", names(qc_anat))
func_cols <- grep("^func_", names(qc_func))
# Rename relevant columns for ease
names(qc_anat) <- sub("anat_", "", names(qc_anat))
names(qc_func) <- sub("func_", "", names(qc_func))
# Only include session 1 and scan 1
qc_anat <- subset(qc_anat, session == 1)
qc_func <- subset(qc_func, session == 1 & scan == 1)
# Fix these weird labels
to_num <- function(x) as.numeric(as.character(x))
qc_anat[,anat_cols] <- apply(qc_anat[,anat_cols], 2, to_num)
qc_func[,func_cols] <- apply(qc_func[,func_cols], 2, to_num)
# Update site labels
qc_anat$site <- factor(qc_anat$site)
qc_func$site <- factor(qc_func$site)
#' ## Correlate
#+ corr-correlate
# anatomical
all_zmats <- daply(qc_anat, .(site), function(x) {
cmat <- cor(x[,anat_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_anat, .(site), nrow)
inds <- ns>10
mean_df <- mean(sqrt(ns[inds]-3))
corr_anat <- apply(all_zmats[inds,,], c(2,3), function(x) tanh(mean(x)/mean_df))
corr_anat_p <- pcor0(abs(corr_anat), mean(ns), lower.tail=F)
# functional
all_zmats <- daply(qc_func, .(site), function(x) {
cmat <- cor(x[,func_cols], use="pairwise.complete.obs")
cmat[cmat>0.9999999] <- 0.9999999 # clamp
zmat <- atanh(cmat) * sqrt(nrow(x) - 3)
zmat
})
ns <- daply(qc_func, .(site), nrow)
inds <- ns>10
mean_df <- mean(sqrt(ns[inds]-3))
corr_func <- apply(all_zmats[inds,,], c(2,3), function(x) tanh(mean(x)/mean_df))
corr_func_p <- pcor0(abs(corr_func), mean(ns), lower.tail=F)
# old way
corr_anat_orig <- cor(qc_anat[,anat_cols], use="pairwise.complete.obs")
corr_func_orig <- cor(qc_func[,func_cols], use="pairwise.complete.obs")
#' # Visualize
#'
#' We look at the abide and corr results together.
#'
#' ## Fixes
#' Since CoRR is missing outliers, we remove that from the abide results
#+ viz-fix-rmcol
rmcol <- which(colnames(abide_func) == "outlier")
abide_func <- abide_func[-rmcol,-rmcol]
abide_func_p <- abide_func_p[-rmcol,-rmcol]
#' We also want to ensure the column names are in the same order.
#' The anatomical is actually fine so only do func cols.
#' We match in reference to the abide functional colnames
#+ viz-fix-ordercol
# anat
all(colnames(abide_anat) == colnames(corr_anat))
# func
ref <- colnames(abide_func)
trg <- colnames(corr_func)
inds <- sapply(ref, function(x) which(trg == x))
corr_func0 <- corr_func # just in case
corr_func <- corr_func0[inds,inds]
#' Now we can combine the two together for one big happy family
#'+ viz-fix-combine
# anat
anat <- abide_anat
anat[upper.tri(anat)] <- corr_anat[upper.tri(anat)]
anat_p <- abide_anat_p
anat_p[upper.tri(anat_p)] <- corr_anat_p[upper.tri(anat_p)]
# func (remove the num_fd column since redundant)
func <- abide_func
func[upper.tri(func)] <- corr_func[upper.tri(func)]
rmind <- which(colnames(func) == "num_fd")
func <- func[-rmind,-rmind]
func_p <- abide_func_p
func_p[upper.tri(func_p)] <- corr_func_p[upper.tri(func_p)]
rmind <- which(colnames(func_p) == "num_fd")
func_p <- func_p[-rmind,-rmind]
?corrplot
cols <- rev(brewer.pal(10, "RdBu"))
quartz()
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1, p.mat=anat_p)
quartz.save("bysite_sig_anat_corrplot.png", width=5, height=5)
corrplot(func, method="color", diag=F, outline=F, col=cols, cl.length=length(cols)+1, p.mat=func_p)
quartz.save("bysite_sig_func_corrplot.png", width=4, height=4)
dev.off()
cols <- rev(brewer.pal(10, "RdBu"))
corrplot(func, method="color", diag=F, outline=F, col=cols, cl.length=length(cols)+1, p.mat=func_p)
dim(anat)
anat
inds <- sapply(c("cnr", "efc", "fber", "fwhm", "qi1", "snr"), function(x) which(colnames(anat)==x))
inds
old_labels <- c("cnr", "efc", "fber", "fwhm", "qi1", "snr")
new_labels <- c("CNR", "EFC", "FBER", "FWHM", "Qi1", "SNR")
inds <- sapply(old_labels, function(x) which(colnames(anat)==x))
colnames(anat) <- new_labels[inds]
rownames(anat) <- new_labels[inds]
func
old_labels <- c( "efc","fber","fwhm","gsr","dvars","quality","mean_fd","perc_fd")
new_labels <- c("EFC", "FBER", "FWHM", "GSR", "DVARS", "Quality", "Mean FD", "Percent FD")
inds <- sapply(old_labels, function(x) which(colnames(func)==x))
colnames(func) <- new_labels[inds]
rownames(func) <- new_labels[inds]
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1, p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
cl.cex=2, cl.col="grey", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
t1.cex=2, t1.col="grey", p.mat=anat_p)
warnings()
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="grey", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="grey70", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="grey90", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="grey20", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", cl.cex=1, p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", cl.cex=1, cl.align.text='l', p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", cl.cex=1, cl.align.text='l', p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", cl.cex=1, cl.align.text='r', p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", cl.cex=1, cl.align.text='c', p.mat=anat_p)
corrplot(anat, method="color", diag=F, outline=F,  col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", p.mat=anat_p)
corrplot(func, method="color", diag=F, outline=F, col=cols, cl.length=length(cols)+1,
tl.cex=2, tl.col="black", p.mat=func_p)
length(unique(qc_anat$site))
length(unique(qc_func$site))
length(unique(qc_anat$subject))
length(unique(corr_anat$site))
length(unique(corr_anat$site))
head(corr_anat)
qc_anat <- read.csv("../data/abide_anat.csv", row.names=1)
qc_func <- read.csv("../data/abide_func.csv", row.names=1)
length(unique(qc_anat$subject))
length(unique(qc_anat$site))
qc_anat <- read.csv("../data/corr_anat.csv", row.names=1)
qc_func <- read.csv("../data/corr_func.csv", row.names=1)
